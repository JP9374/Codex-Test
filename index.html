<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Starlink Constellation Globe</title>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        color: #f5f7ff;
        background: radial-gradient(circle at top, #0d1d3b, #02040f 70%);
        overflow: hidden;
      }

      canvas {
        display: block;
      }

      .hud {
        position: fixed;
        top: 16px;
        left: 16px;
        padding: 12px 16px;
        background: rgba(8, 16, 40, 0.65);
        border: 1px solid rgba(108, 153, 255, 0.35);
        border-radius: 12px;
        backdrop-filter: blur(12px);
        box-shadow: 0 10px 35px rgba(1, 5, 20, 0.45);
        max-width: min(360px, calc(100vw - 32px));
      }

      .hud h1 {
        margin: 0 0 8px;
        font-size: 1.1rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .hud p {
        margin: 4px 0;
        font-size: 0.9rem;
        line-height: 1.4;
        color: rgba(226, 235, 255, 0.8);
      }

      .hud p strong {
        color: #8cb5ff;
      }

      .hud .status-error {
        color: #ffadad;
      }

      a {
        color: #9dc1ff;
        text-decoration: none;
      }

      a:hover {
        text-decoration: underline;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.js" defer></script>
  </head>
  <body>
    <div class="hud" aria-live="polite">
      <h1>Starlink Constellation</h1>
      <p>
        Visualising live orbital positions of the Starlink satellites provided by the
        <a href="https://celestek.space/" target="_blank" rel="noopener">Celestek API</a>.
      </p>
      <p><strong>Satellites tracked:</strong> <span id="satellite-count">—</span></p>
      <p><strong>Last update:</strong> <span id="last-update">Fetching…</span></p>
      <p id="status-message"></p>
    </div>

    <script>
      window.addEventListener("load", () => {
        const EARTH_RADIUS_KM = 6371;
        const EARTH_RADIUS_UNITS = 5;
        const ALTITUDE_SCALE = EARTH_RADIUS_UNITS / EARTH_RADIUS_KM;
        const API_URL = "https://api.celestek.com/v1/satellites/starlink";
        const REFRESH_INTERVAL = 60_000;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x02040f, 0.035);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 8, 16);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 7;
        controls.maxDistance = 40;

        const ambientLight = new THREE.AmbientLight(0xe4f2ff, 0.55);
        scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight(0xffffff, 1.25);
        keyLight.position.set(12, 8, 6);
        scene.add(keyLight);

        const earthTexture = new THREE.TextureLoader().load(
          "https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg"
        );
        const earthNormalMap = new THREE.TextureLoader().load(
          "https://threejs.org/examples/textures/planets/earth_normal_2048.jpg"
        );
        const earthSpecularMap = new THREE.TextureLoader().load(
          "https://threejs.org/examples/textures/planets/earth_specular_2048.jpg"
        );

        const earthMaterial = new THREE.MeshPhongMaterial({
          map: earthTexture,
          normalMap: earthNormalMap,
          specularMap: earthSpecularMap,
          specular: new THREE.Color(0x202020),
          shininess: 12
        });

        const earthMesh = new THREE.Mesh(new THREE.SphereGeometry(EARTH_RADIUS_UNITS, 128, 128), earthMaterial);
        scene.add(earthMesh);

        const atmosphere = new THREE.Mesh(
          new THREE.SphereGeometry(EARTH_RADIUS_UNITS * 1.06, 64, 64),
          new THREE.MeshPhongMaterial({
            color: 0x4b72ff,
            side: THREE.BackSide,
            transparent: true,
            opacity: 0.25,
            blending: THREE.AdditiveBlending
          })
        );
        scene.add(atmosphere);

        const glow = new THREE.Mesh(
          new THREE.SphereGeometry(EARTH_RADIUS_UNITS * 1.08, 64, 64),
          new THREE.MeshBasicMaterial({
            color: 0x1c2e4f,
            side: THREE.BackSide,
            transparent: true,
            opacity: 0.35
          })
        );
        scene.add(glow);

        const starVertices = [];
        for (let i = 0; i < 2500; i += 1) {
          const radius = 160;
          const theta = THREE.MathUtils.randFloatSpread(360) * (Math.PI / 180);
          const phi = THREE.MathUtils.randFloatSpread(360) * (Math.PI / 180);
          const x = radius * Math.cos(theta) * Math.sin(phi);
          const y = radius * Math.sin(theta) * Math.sin(phi);
          const z = radius * Math.cos(phi);
          starVertices.push(x, y, z);
        }
        const starFieldGeometry = new THREE.BufferGeometry();
        starFieldGeometry.setAttribute("position", new THREE.Float32BufferAttribute(starVertices, 3));
        const starFieldMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.7,
          sizeAttenuation: true,
          transparent: true,
          opacity: 0.8
        });
        const starField = new THREE.Points(starFieldGeometry, starFieldMaterial);
        scene.add(starField);

        const satelliteGroup = new THREE.Group();
        scene.add(satelliteGroup);
        const satellites = new Map();

        const satelliteGeometry = new THREE.SphereGeometry(0.08, 8, 8);
        const satelliteMaterial = new THREE.MeshBasicMaterial({ color: 0xffc857 });

        function latLonAltToVector3(lat, lon, altitudeKm) {
          const phi = (90 - lat) * (Math.PI / 180);
          const theta = (lon + 180) * (Math.PI / 180);
          const radius = EARTH_RADIUS_UNITS + Math.max(0, altitudeKm) * ALTITUDE_SCALE;
          const sinPhi = Math.sin(phi);
          return new THREE.Vector3(
            radius * sinPhi * Math.cos(theta),
            radius * Math.cos(phi),
            radius * sinPhi * Math.sin(theta)
          );
        }

        function updateSatellites(satelliteData) {
          const activeIds = new Set();

          satelliteData.forEach((satellite) => {
            const id = satellite.satelliteId || satellite.noradId || satellite.id || satellite.name;
            if (!id) {
              return;
            }
            activeIds.add(id);

            let mesh = satellites.get(id);
            if (!mesh) {
              mesh = new THREE.Mesh(satelliteGeometry, satelliteMaterial.clone());
              mesh.material.color.offsetHSL(Math.random() * 0.05, 0, Math.random() * 0.05);
              satelliteGroup.add(mesh);
              satellites.set(id, mesh);
            }

            const latitude = Number(satellite.latitude ?? satellite.lat ?? 0);
            const longitude = Number(satellite.longitude ?? satellite.lon ?? 0);
            const altitudeKm = Number(satellite.altitude_km ?? satellite.altitudeKm ?? satellite.altitude ?? 0);
            const position = latLonAltToVector3(latitude, longitude, altitudeKm);
            mesh.position.copy(position);
          });

          satellites.forEach((mesh, id) => {
            if (!activeIds.has(id)) {
              satelliteGroup.remove(mesh);
              mesh.geometry.dispose();
              mesh.material.dispose();
              satellites.delete(id);
            }
          });

          document.getElementById("satellite-count").textContent = satellites.size.toLocaleString();
        }

        async function fetchSatellitePositions() {
          const statusElement = document.getElementById("status-message");
          try {
            statusElement.textContent = "";
            statusElement.classList.remove("status-error");
            const response = await fetch(API_URL, { cache: "no-store" });
            if (!response.ok) {
              throw new Error(`HTTP ${response.status} – ${response.statusText}`);
            }
            const payload = await response.json();
            const constellation = Array.isArray(payload)
              ? payload
              : payload.satellites || payload.results || payload.data || [];
            updateSatellites(constellation);
            const timestamp = new Date();
            document.getElementById("last-update").textContent = timestamp.toLocaleTimeString();
          } catch (error) {
            console.error("Failed to fetch satellite data", error);
            statusElement.textContent = "Unable to refresh live satellite positions right now.";
            statusElement.classList.add("status-error");
          }
        }

        function animate() {
          requestAnimationFrame(animate);
          earthMesh.rotation.y += 0.0005;
          atmosphere.rotation.y += 0.0006;
          glow.rotation.y += 0.0006;
          starField.rotation.y += 0.00005;
          controls.update();
          renderer.render(scene, camera);
        }

        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener("resize", onWindowResize);

        fetchSatellitePositions();
        setInterval(fetchSatellitePositions, REFRESH_INTERVAL);
        animate();
      });
    </script>
  </body>
</html>
